%$Id: w05_spreading.tex gnawux $
%  vim: set ft=tex:
\chapter{移动个人网络中的分布式信息存储}

\section{引言}

分布式终端系统中的高级节点的关键任务之一是维护系统的状态，即分布式地存储系统中的可用资源信息与系统中的业务应用的状态信息，保障这些信息在移动过程中的可靠性和节点大量变动的情况下数据存取的高效性，同时，数据维持工作也应该较低地消耗节点的计算、存储、通信带宽和能量资源，尽量少地影响系统中运行的其它应用。

\section{对等网络中的分布式数据存储方式}

As a centralized directory such as that in Service Location Protocol (SLP) or Jini is hard to survive in mobility event of mobile personal networks, decentralized directory and data replication among nodes are adopted in order to improve the robustness. Discrete Hash Table (DHT) based methods, such as chord \cite{bib:chord_sigcom} and pastry \cite{bib:pastry}, enable a distributed storage infrastructure for Internet, however, each node in a DHT ring should keep routing information of $O(\log{}N)$ peers and an additional node's joining costs a lookup ($O(\log{}N)$ messages) and updating routing informations in $O(\log{}N)$ nodes \cite{bib:chord_sigcom}. As the nodes often joining a mobile personal network as groups, DHT based infrastructure may not handle it effectively. 

On the other hand, Huang and Chen \cite{bib:huang06} proposed a data replication method considering group mobility in MANET, in which a hierarchical structure is adopted. 

\subsection{结构化方式存储}

\subsection{非结构化方式存储}

\section{移动个人网络的分布式数据存储}

具体地考虑移动个人网络中的分布式数据存储，

若移动个人网络中有~$n$~个节点，$N_1, N_2,\cdots,N_n$，它们分布在网络中的~$l$~个异构链路~$L_1, L2,\cdots,L_l$~上，其中有~$s$~个高级节点~($N_{S_1}, N_{S_2},\cdots,N_{S_s}$)~可以用于存储系统信息。当发生移动事件的时候，原有高级节点上的数据需要在变化之后的~$n'$~个节点中的~$s'$~个高级节点中重新分布，
\begin{eqnarray}
	n' = & \!\!\!\!n+\Delta{}n, & \Delta{}n > -n\\
	s' = & \!\!\!\!s+\Delta{}s, & \Delta{}s > -s\\
	      &	    		& 0\le{}\frac{\Delta{}s}{\Delta{}n}\le{}1.\nonumber
	\label{equ:nodesch}
\end{eqnarray}

移动个人网络中所涉及到的系统信息分为两类，其一是设备提供的能力服务器的描述信息，另一类则是系统中的应用会话相关信息。如表~\ref{tab:server}，一个能力服务器的描述信息不仅包含它的标识~(ServerID)、其提供的服务类型与能力等信息，同时还包括一个组标识~(GroupID)~用于描述其所在的组，这些信息可以用于帮助在服务发现的过程中应用选择恰当的服务器。而应用的描述信息~(表~\ref{tab:app})~则用于保存应用状态、维持业务连续性，其中包含了应用的~ID~和正在使用的或需要的能力服务器的相关描述。这样，如果系统现有能力无法维持业务继续运行则会终止应用，如果系统中有了新的能力服务器可用可以通知应用，甚至在能力服务器发生更替的时候可以及时利用先有资源重新生成业务、维持业务的连续性，这里，用于回调的地址可以是本地移动个人网络中的，也可以包含广域网络中的远程服务器地址描述。

\begin{table}
	\centering
	\caption{能力服务器的描述信息}
	\label{tab:server}
	\begin{tabular}{lll}
		\hline
		数据字段		& 描述内容							& 数据类型	\\
		\hline
		ServiceTypeID	& 服务器提供的服务类型				& string	\\
		ServerID		& 能力服务器的惟一标识				& string	\\
		DeviceID		& 提供能力服务器的设备			 	& string 	\\
		GroupID 		& 能力服务器所在设备的所属组		& string 	\\
		NormalizedCapa 	& 能力服务器的归一化能力描述		& integer 	\\
		UsedBy			& 目前使用此能力的应用				& string	\\
		TTL				& 此能力服务器描述的有效期			& integer	\\
		Capability		& 服务器能力的具体描述				& string	\\
		\hline
	\end{tabular}
\end{table}

\begin{table}
	\centering
	\caption{应用会话的描述信息}
	\label{tab:app}
	\begin{tabular}{lll}
		\hline
		数据字段		& 描述内容							& 数据类型	\\
		\hline
		AppID			& 应用会话的惟一标识				& string \\
		Location		& 应用的回调接口地址				& string	\\
		Required		& 应用所必须的能力服务器及能力		& string	\\
		Recommended		& 应用所需的其他能力服务器及能力	& string	\\
		Using			& 当前使用的能力服务器				& string	\\
		\hline
	\end{tabular}
\end{table}

所有这些记录都是由一组给定的键值对~(AVP, Attribute Value Pair)~组成的记录信息，并且具有各自的惟一标识，通过将这些数据放入统一的目录之中，即可通过各种组合查询手段找到需要的能力服务器或应用会话相关信息。而上述两类信息作为服务发现机制的数据源和结果又具有一些不同属性，例如，能力服务器信息是依附于其所在设备的，而设备是具有成组移动特性；相反，应用是全局性的信息，不带有分组性，并且，在发生移动的时候，业务应尽量保持连续性。

%In proposed protocol, only application entries are maintained system-wise so that the applications can be recomposed even if serving devices leave the system, while the CS entries of devices are maintained in the scope of group, therefore, the minimization of system-wise status \cite{bib:prehofer05} cuts down the cost of reorganizing the directory. All the SNs in mobile personal networks have some memory for maintaining a database of the directory entries for service discovery.
%后面分析中可以考虑把分布范围放在组或全局，考量不同的性能影响，不过下面那个一定是考虑组移动性的否则似乎优点不大


\subsection{移动个人网络数据的无中心组织方法}

%尽量减少全局状态，以组为单位是个折衷，全局信息全局存储，小组信息小组存储
对于全局信息的存储，为了均衡各个节点的负担，提高系统的可靠性和可伸缩性，论文中采用了一种将数据以无中心方式分布到各个节点之上的方法，并通过一定的冗余度，保障在节点大规模损失的情况下的数据可靠性。数据信息会被组播到所有的高级节点，而每个高级节点都通过一个自己的优先级算法，将优先级较高的一些记录保存在自己的存储空间之中，而不保存优先级较低的记录。每条记录在特定节点的优先级~($P_d(r)$)~的计算是通过一个哈希函数~($h(\cdot)$)~来实现的：定义记录的~ID~和节点的~ID~哈希值的距离为该记录在此节点上的存储优先级
\begin{equation}
	P_{d}(r)=|h(r)-h(d)|
	\label{eq:priority}
\end{equation}
这里，哈希值的分布特性将决定存储的分布特征，为了保证数据分布的均匀性，论文选择了常用的~SHA-1~算法作为哈希函数，对于非特殊选择的~ID，其哈希值应遵循均匀分布。在这种情况下，对于存储于~$s$~个高级节点中的~$r$~条信息，如果每个高级节点存储~$\gamma$~条信息，则信息冗余度大致为
\begin{equation}
	\rho=\frac{\gamma{}s}{r}.
	\label{eq:redundancy}
\end{equation}

\subsection{目录数据向新加入节点传播}

在发生服务发现事件的时候，高级节点会自然地更新其存储的数据，除此之外，它们还通过目录更新消息来更新彼此存储的目录信息，每个高级节点都会以一定时间周期来公布它所存储的目录数据，这个更新周期~$T_u$~是由其上一次收到目录更新消息的时间~$T_{u0}$~和其存储的目录数据所确定的
\begin{equation}
	T_u = T_{u0} + T_r\cdot{}(R-R_D),
	\label{eqn:tupdate}
\end{equation}
其中，$T_r$~是一个均匀分布的随机变量，用以避免碰撞，$R$~是本节点所存储的目录数据的总量，而~$R_D$~是目录中较老的，没有在近期内被更新过的记录的数量，也就是说，有较多未被更新的数据的节点更倾向于较早地发送更新消息。一旦有新节点加入到移动个人网络之中，它们可以通过的目录更新消息得初始化本地目录信息，随后，与正常的目录更新过程一样，它们可以利用得到的目录更新消息调整目录内容，在若干个更新周期之后达到稳定状态。图~\ref{fig:spread-stat}~是单个高级节点的目录数据更新的状态图，图~\ref{fig:replica}~是这一过程的伪代码。

\begin{figure}[tb]
	\begin{center}
		\includegraphics[width=.7\textwidth]{spread-st}
	\end{center}
	\caption{高级节点目录更新状态转移图}
	\label{fig:spread-stat}
\end{figure}

%计算一下 1 初始状态下那个第一次发出更新包的时间的期望，就是前一段算过的那个，再计算一下，多拥有一个过期信息的节点早一点发出更新包的概率

\begin{figure}[htb]
	\begin{center}
	\framebox{%
	\begin{minipage}[t]{.8\textwidth}%
	\texttt{%
\mbox{~}on\_timeout()\\
\mbox{~}\hspace{4ex} sent\_update();\\
\mbox{~}\\
\mbox{~}on\_receive\_solicitation()\\
\mbox{~}\hspace{4ex} t = timer.get\_time();\\
\mbox{~}\hspace{4ex} timer.set\_time( t/entry\_number );\\
\mbox{~}\\
\mbox{~}on\_receive\_update()\\
\mbox{~}\hspace{4ex} time\_stamp = systemtime();\\
\mbox{~}\hspace{4ex} update\_entries(received\_data,time\_stamp);\\
\mbox{~}\hspace{4ex} entry\_diff\_count=0;\\
\mbox{~}\hspace{4ex} for i=1 to record\_number\\
\mbox{~}\hspace{4ex}\hspace{4ex}  if entry[i].time\_stamp < (time\_stamp-threshold)\\
\mbox{~}\hspace{4ex}\hspace{4ex}\hspace{4ex}   entry\_diff\_count++;\\
\mbox{~}\hspace{4ex} timer.set\_time(rand()*\\
\mbox{~}\hspace{4ex}\hspace{4ex}\hspace{4ex}\hspace{4ex}\hspace{4ex} (entry\_number-entry\_diff\_number));%  
	}%
	\end{minipage}%
	}
	\end{center}
	\caption{目录更新过程的伪代码}
	\label{fig:replica}
\end{figure}

由于目录更新消息是在高级节点之间以组播方式传送的，因此，当同时加入节点的数量增加的时候，目录达到稳定的时间不会线性增长。

表~\ref{tab:exam}~是一个节点加入过程的例子：假设原有~15~个高级节点，每个节点存储~8~条目录记录，而总共有~30~条记录，这样，每条记录大约有~4~个备份。表中情况为~4~个高级节点同时加入，它们通过目录更新消息来进行初始化。表~\ref{tab:exam}~中，每个表格代表了一个更新周期，表格的第一行则表示更新消息的内容，圆括号里的数字是发送目录更新消息的节点的编号；表中的其它每行都是代表一个新加入节点的目录内容，其中的内容是按照每条记录在该节点内的优先级来排序的，每次更新后新增加的记录用下划线标明。

如表~\ref{tab:exam}~所示，第一个更新周期之后，所有的新加入高级节点都使用来自~$s_6$~的更新消息进行了初始化。之后，使用来自~$s_5$~的更新消息，第一个新加入节点的数据几乎被完全更新，实际已经达到了稳定状态，而第二个新加入节点也向着稳定状态迈进了一步，其它两个节点则没有更新。最后，在第三个更新周期之中，所有新加入节点都同时进入了稳定状态。

\begin{table}[htb]
	\centering
	\caption{例：4~个高级节点加入一个原有~15~个高级节点的网络}
	\label{tab:exam}
	\begin{tabular}{p{10ex}|rrrrrrrr}
		\hline
		Updates(6) & 	12 &   9 &   1 &  21 &  19 &  17 &  24 &  6 \\
		\hline
		1			&	6  & 24  & 17  & 21  & 19  &  9  &  1  & 12 \\
		2			&	6  & 21  &  9  & 12  &  1  & 19  & 17  & 24 \\
		3			&   21 &   9 &  12 &   1 &   6 &  19 &  17 &  24 \\
		4			&	9  & 12  &  1  & 21  & 19  & 17  &  6  & 24 \\
		\hline
	\end{tabular}
	\vspace{1em}

	\begin{tabular}{p{10ex}|rrrrrrrr}
		\hline
		Updates(5) & 	13 &  27 &  15 &  14 &   7 &   5 &  11 &  16 \\
		\hline
		1			&   \underline{13} &  \underline{27} &  \underline{15} &  \underline{14} &   \underline{7} &   \underline{5} &  \underline{11} &  \underline{16} \\
		2			&    6 &  \underline{16} &  \underline{11} &   \underline{5} &  21 &   \underline{7} &   9 &  12 \\
		3			&   21 &   9 &  12 &   1 &   6 &  19 &  17 &  24 \\
		4			&    9 &  12 &   1 &  21 &  19 &  17 &   6 &  24 \\
		\hline
	\end{tabular}
	\vspace{1em}
	
	\begin{tabular}{p{10ex}|rrrrrrrr}
		\hline
		Updates(13) &   10 &  30 &   3 &  22 &  28 &   8 &   6 &   2 \\
		\hline
		1			&   13 &  27 &  15 &  14 &   7 &   5 &  11 &  16 \\
		2			&   \underline{28} &  \underline{22} &   \underline{3} &  \underline{30} &  \underline{10} &   \underline{2} &   \underline{8} &   6 \\
		3			&   21 &   9 &  12 &   1 &   6 &   \underline{8} &  \underline{10} &  19 \\
		4			&    9 &  12 &   1 &  21 &  19 &  17 &   6 &   \underline{8} \\
		\hline
	\end{tabular}
\end{table}

可以看到，所有节点的目录条目更新是并行进行的。诸如~chord~等~DHT~类的分布式存储算法，并不考虑这种大量节点同时加入的情况，而论文所述的方法因为更新消息是组播到所有高级节点的，所以，不仅可以平稳地处理这些节点的同时加入，而且可以以较高的效率并行处理，甚至在新加入高级节点的数量超过原有高级节点数量的时候也可以稳定工作。图~\ref{fig:spread}~所示的仿真工作就表明了这一点。

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=.7\textwidth]{images/spread}
	\end{center}
	\caption{Effects of Joining Nodes and Updating Period}
	\label{fig:spread}
\end{figure}

如图~\ref{fig:spread}，同样假设原有~15~个高级节点，每个节点存储总共~30~条目录条目中的~8~条，当加入的高级节点数目分别为~$1, 2, 4, 8,\cdots,128$~个的时候，随着加入节点数量的指数增长，新加入节点所需要的目录更新周期数量以一条想对平缓的曲线增长，这一增长是由于\ldots造成的
%计算一下，多一个节点发送完整数据所需要的时间长多少，也就是说，n+1 中，n 发送的概率有多高，这个还比较难说
另外，更新消息发送计时器的设置会影响各个高级节点发送更新消息的概率，图~\ref{fig:spread}~显示，较高的更新计时器定时值设置可以帮助新加入节点尽早达到稳定状态，因为这样可以让较老的数据更快地被标记为过期，从而增大发送概率。


\section{性能分析与仿真}

\subsection{数据的存活能力}

节点退出的性能，消耗多少存储量，可以保障多高冗余度的概率分析

\subsection{查找数据的性能}

确知的知道多少步骤可以找到所需数据

\subsection{数据再分布的性能}

节点加入的性能，加入的数据需要消耗多少信息量才能稳定

\section{小结}

